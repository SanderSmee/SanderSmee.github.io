

[
  
  
    
    
      {
        "title": "Combining Spock 1.2 and Junit 5 tests",
        "excerpt": "\n\n\n\n\n\n\n2018-10-01: Update for Spock 1.2 release\n\n\n\n\n\nGreat projects keep moving forward. JUnit5 is available since september 2017 and Spock 1.2 was completed in september 2018.\nSince Spock is based on junit4, I wondered what it would take to use Spock 1.2 together with JUnit5.\n\n",
        "content": "\n\n\n\n\n\n\n2018-10-01: Update for Spock 1.2 release\n\n\n\n\n\nGreat projects keep moving forward. JUnit5 is available since september 2017 and Spock 1.2 was completed in september 2018.\nSince Spock is based on junit4, I wondered what it would take to use Spock 1.2 together with JUnit5.\n\n\nAs it turns out, it&#8217;s quite easy to make that happen. JUnit5 comes with a vintage engine to run junit4 based tests. If that is available on the test classpath, your Spock tests run like on junit4.\n\n\nThe following example is based on gradle, and is the minimum for getting started in gradle. It declares the dependencies and instructs gradle to use the JUnit5 JUnitPlatform to execute the tests.\n\n\nI have a sample repository that includes a maven pom.xml. The repository also includes a JUnit5 test, to prove that a combination of JUnit5 and Spock tests can exist in the same project.\n\n\n\nplugins {\n  id 'java'\n  id 'groovy'\n}\n\nrepositories {\n  mavenCentral()\n}\n\nsourceCompatibility = 1.8\n\ndependencies {\n  testCompile \"org.spockframework:spock-core:1.2-groovy-2.5\"\n  implementation \"org.junit.jupiter:junit-jupiter-api:5.3.0\"\n  testRuntimeOnly \"org.junit.vintage:junit-vintage-engine:5.3.0\"\n}\n\ntest {\n  useJUnitPlatform()\n}\n\n\n\n\n\nWritten with Spock 1.2, JUnit 5.3.0, and Gradle 4.10\n\n\n\n",
        "url": "/2018/09/spock-jupiter/"
      },
    
      {
        "title": "Asciidoc labels like swagger-ui",
        "excerpt": "\nIf you&#8217;re building a rest api with spring-boot and want to document the api, you have two good options to do this; Springfox, or Spring REST Docs.\nSpringfox creates (interactive) documentation through a swagger-ui to use by a developer, Spring REST Docs creates documentation via asciidoc.\nAnd what&#8217;s best is that you can simply combine the two in a project.\n\n",
        "content": "\nIf you&#8217;re building a rest api with spring-boot and want to document the api, you have two good options to do this; Springfox, or Spring REST Docs.\nSpringfox creates (interactive) documentation through a swagger-ui to use by a developer, Spring REST Docs creates documentation via asciidoc.\nAnd what&#8217;s best is that you can simply combine the two in a project.\n\n\nI wanted to create some connection or similarity between the swagger-ui and asciidoc documentation.\nI came across a blogpost by mrhaki that inspired me to extend the snippets in his example.\n\n\nUsing the following snippets, it&#8217;s possible to label HTTP verbs in the Spring REST Docs in the same colors as in the swagger-ui.\n\n\nAsciidoc variables\n\n= Attributes with HTTP labels\n// Include contents of docinfo.html in HTML head with CSS style definitions\n:docinfo1:\n\n// Document attributes with styling\n:http-get: pass:quotes[[.http.get]#GET#]\n:http-post: pass:quotes[[.http.post]#POST#]\n:http-put: pass:quotes[[.http.put]#PUT#]\n// More can be added for the other HTTP verbs\n\n== Sample section\n\n=== {http-get} Request\n=== {http-post} Create resource\n=== {http-put} Modify resource\n\n\n\nBelow is the docinfo.html with the CSS style definitions.\nIt contains colors for all verbs, corresponding to the default swagger-ui colors.\n\n\ndocinfo.html file\n\n&lt;style&gt;\n.http {\n    color: #fff;\n    background-color: beige;\n    padding: .1em .6em;\n    font-size: .75em;\n    font-weight: 700;\n    text-transform: uppercase;\n    border-radius: .25em;\n}\n\n.http.get  {background-color: #61affe;}\n.http.post {background-color: #49cc90;}\n.http.put  {background-color: #fca130;}\n.http.delete {background-color: #f93e3e;}\n.http.head {background-color: #9012fe;}\n.http.options {background-color: #0d5aa7;}\n.http.patch {background-color: #50e3c2;}\n&lt;/style&gt;\n\n\n\nThis gives the following result in the Spring REST Docs output.\n\n\n\n\n\n\n\n\n\nWritten with Asciidoc 1.5.6\n\n\n\n",
        "url": "/2018/09/asciidoc-swagger/"
      },
    
      {
        "title": "Plantuml labels like swagger-ui",
        "excerpt": "\nIt&#8217;s great to have Asciidoc labels like swagger-ui in the documentation, but would it be possible to extend this even further?\nIn asciidoc documentation I also use Plantuml diagrams, e.g. to illustrate the sequence of interaction between microservices.\nIs it possible to label those interactions like swagger-ui, just as I now can in asciidoc?\n\n",
        "content": "\nIt&#8217;s great to have Asciidoc labels like swagger-ui in the documentation, but would it be possible to extend this even further?\nIn asciidoc documentation I also use Plantuml diagrams, e.g. to illustrate the sequence of interaction between microservices.\nIs it possible to label those interactions like swagger-ui, just as I now can in asciidoc?\n\n\nIn Plantuml it&#8217;s possible to declare macros.\nI created a reusable macro for a message in a sequence diagram, that has a note next to it.\nBy giving the note a stereotype it can have custom styling in the diagram, and can look like a label.\n\n\n\n@startuml\n!definelong Request(verb, msg, desc)\nmsg : desc\nrnote &lt;&lt;verb&gt;&gt;&lt;&lt;HTTP&gt;&gt; left color\n\"\"verb\"\"\nend note\n!enddefinelong\n\n!define GET(msg, desc) Request(\" GET \", msg, desc)\n!define POST(msg, desc) Request(\" POST \", msg, desc)\n!define PUT(msg, desc) Request(\" PUT \", msg, desc)\n\nactor User\nUser --&gt; Browser : click resource\nGET(Browser --&gt; Resource, /path/to/resource)\nBrowser &lt;-- Resource : response\nPOST(Browser -&gt; Resource, '\"\"JSON\"\" new Resource')\nnote right\n  more note to\n  this message\nend note\nUser &lt;-- Browser : display resource\n@enduml\n\n\n\nTo give the note a style resembling a label I used the following styling.\nFirst some generic styling for each label, based on the [HTTP] stereotype.\nSpecific styling for a verb goes through its own [verb] stereotype.\n\n\n\nskinparam note&lt;&lt;HTTP&gt;&gt; {\n  textAlignment center\n  backgroundColor #darkgrey\n  borderColor transparent\n  fontName monospaced\n  fontColor #fff\n  shadowing false\n}\nskinparam noteBackgroundColor&lt;&lt;GET&gt;&gt; #61affe\nskinparam noteBackgroundColor&lt;&lt;POST&gt;&gt; #49cc90\nskinparam noteBackgroundColor&lt;&lt;PUT&gt;&gt; #fca130\nskinparam noteBackgroundColor&lt;&lt;DELETE&gt;&gt; #f93e3e\nskinparam noteBackgroundColor&lt;&lt;HEAD&gt;&gt; #9012fe\nskinparam noteBackgroundColor&lt;&lt;OPTIONS&gt;&gt; #0d5aa7\nskinparam noteBackgroundColor&lt;&lt;PATCH&gt;&gt; #50e3c2\n\n\n\nThe following results in this diagram:\n\n\n\n\n\n\n\n\n\nWritten with Plantuml 1.2018.10\n\n\n\n",
        "url": "/2018/09/plantuml-swagger/"
      },
    
      {
        "title": "Easily build your own tech radar",
        "excerpt": "\nThe Thoughtworks Technology Radar is well known for showing technology trends and choices.\nFor my project I wanted to have the same thing, not use the hosted public version from Thoughtworks, but a selfhosted option.\nTherefore I choose to base it on the Zalando opensource tech radar, and create a way to use a CSV file as input so updating would be an easy thing to do.\n\n",
        "content": "\nThe Thoughtworks Technology Radar is well known for showing technology trends and choices.\nFor my project I wanted to have the same thing, not use the hosted public version from Thoughtworks, but a selfhosted option.\nTherefore I choose to base it on the Zalando opensource tech radar, and create a way to use a CSV file as input so updating would be an easy thing to do.\n\n\nTo accomplish that I took the following steps:\n\n\n\n\nCreate a folder to put the tech radar into: ${project-folder}.\n\n\nStart with the HTML5 Boilerplate index.html file, and put it into ${project-folder}.\n\n\nInsert the snippets as documented at Zalando Tech Radar, with one adjustment.\nI don&#8217;t fill the entries array with entries, but will do that later on, from the input in the CSV file.\n\n\nCreate a CSV file (${project-folder}/data.csv) as input for the tech radar.\nIt has columns for the ring and quadrant where a technology should be put, and an indicator for movement.\nThe names of the rings and quadrant should equal those in the configuration copied from the Zalando example.\nIf you changed them, use those names instead.\nThe movement indicator is (up, none, down) and in the next step translated in to value understood by the radar.\nThe CSV will be translated into entries for the radar.\n\n\nname,ring,quadrant,moved,link\nJava,INNER,Bottom Right,none,../docs/java.html\nTypescript,SECOND,Top Left,up,../docs/typescript.html\n\n\n\n\nAdd the following D3.js library to parse CSV:\n\n\n&lt;script src=\"https://d3js.org/d3-dsv.v1.min.js\"&gt;&lt;/script&gt;\n\n\n\nThis library provides functions to parse CSV file(s) into a map structure per row in the file.\n\n\n\nCreate a function to transform a row in the CSV into an entry for the tech radar:\n\n\nfunction toEntry(row) {\n    return {\n        label: row.name,\n        quadrant: ['Bottom Right', 'Bottom Left', 'Top Left', 'Top Right'].indexOf(row.quadrant),\n        ring: ['INNER', 'SECOND', 'THIRD', 'OUTER'].indexOf(row.ring),\n        link: row.link,\n        moved: ['down', 'none', 'up'].indexOf(row.moved) - 1,\n        active: true\n    }\n}\n\n\n\n\nThis is the diversion from the steps in the Zalando tech radar description.\nWrap the radar_visualization() function a custom one, that takes an array of entry, to render the transformed rows, e.g. draw_radar(entries).\n\n\nfunction draw_radar(my_entries) {\n    radar_visualization({\n        ...\n        entries: my_entries\n    });\n}\n\n\n\n\nFinally glue everything together to fetch the CSV, parse and transform it, and draw the entries.\nThe code below uses the functions I defined in the previous steps\n\n\nfetch('./data.csv')\n    .then(function (resp) {\n        return resp.text();\n    })\n    .then(function (csv) {\n        var entries = d3.csvParse(csv, function (row) {\n            return toEntry(row);\n        });\n        draw_radar(entries);\n    });\n\n\n\n\n\n",
        "url": "/2018/10/easily-build-your-own-tech-radar/"
      },
    
      {
        "title": "Reduce the code to noise ratio of maven POMs",
        "excerpt": "\nI really like maven for the structured way it provides for defining and building a project.\nBut sometimes I wish for a less verbose notation than the XML of the Project Object Model (POM).\nFor example, gradles dependency notation is far shorter than mavens dependency declaration.\n\n",
        "content": "\nI really like maven for the structured way it provides for defining and building a project.\nBut sometimes I wish for a less verbose notation than the XML of the Project Object Model (POM).\nFor example, gradles dependency notation is far shorter than mavens dependency declaration.\n\n\nLooking for a less verbose way to declare a maven POM, I discovered polyglot maven.\nIt are maven extensions that allow the maven POM to eb written in another dialect than XML.\nSince you see YAML more and more I decided to try that dialect, and see if my maven descriptor would be clearer.\n\n\nThe minimum version of maven this works on, is maven 3.3.1. Since that version it&#8217;s possible to provide per project configuration. or extension of maven.\n\n\n\n\nCreate a directory to work in, {projectdir}, and change into it.\n\n\nTo register the extensions for maven, create a file {projectdir}/.mvn/extensions.xml and add the extension:\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;extensions&gt;\n    &lt;extension&gt;\n        &lt;groupId&gt;io.takari.polyglot&lt;/groupId&gt;\n        &lt;artifactId&gt;polyglot-yaml&lt;/artifactId&gt;\n        &lt;version&gt;0.3.1&lt;/version&gt;\n    &lt;/extension&gt;\n&lt;/extensions&gt;\n\n\n\n\nNow it&#8217;s possile to write the maven POM in YAML, pom.yml:\n\n\nmodelVersion: 4.0.0\ngroupId: demo.maven.polyglot\nartifactId: yml-demo\nversion: 1.0-SNAPSHOT\nname: 'YAML Demo'\n\ndependencies:\n- { groupId: org.junit.jupiter, artifactId: junit-jupiter, version: 5.3.1, scope: test }\nplugins:\n- artifactId: maven-compiler-plugin\n    version: 3.8.0\n    configuration:\n    source: 1.8\n    target: 1.8\n- artifactId: maven-surefire-plugin\n    version: 2.22.1\n\n\n\nBy using the yaml inline map. or dictionary notation declaring a dependency uses way less characters then when using XML.\n\n\n\n\n\nLimitations\n\n\nAlthough this looks great, there are some limitations to using maven polyglot.\nMixing different dialects is not possible, and plugins depending on the XML format will not work with another dialect.\nI also could not get a multi module project working with polyglot yaml.\n\n\n\n",
        "url": "/2018/10/reduce-code-noise-ratio-maven-poms/"
      },
    
  
  
  
  {
    "title": "About",
    "excerpt": "\n",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com\n\nYou can find the source code for Minima at GitHub:\njekyll /\nminima\n\nYou can find the source code for Jekyll at GitHub:\njekyll /\njekyll\n\n",
    "url": "/about/"
  },
  
  {
    "title": "Documentation",
    "excerpt": "\n",
    "content": "\n",
    "url": "/category/documentation/"
  },
  
  {
    "title": "Home",
    "excerpt": "\n",
    "content": "\n",
    "url": "/"
  },
  
  {
    "title": "Programming",
    "excerpt": "\n",
    "content": "\n",
    "url": "/category/programming/"
  },
  
  {
    "title": "Search",
    "excerpt": "\n",
    "content": "\n",
    "url": "/search/"
  },
  
  {
    "title": "Tags",
    "excerpt": "\n",
    "content": "\n",
    "url": "/tags/"
  }
  
]

